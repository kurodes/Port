/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DMService_H
#define DMService_H

#include <thrift/TDispatchProcessor.h>
#include "LocofsRpc_types.h"

namespace LocofsRpc {

class DMServiceIf {
 public:
  virtual ~DMServiceIf() {}
  virtual int32_t mkdir(const std::string& path, const DirectoryInode& di) = 0;
  virtual int32_t access(const std::string& path, const DirectoryInode& di) = 0;
  virtual int32_t chown(const std::string& path, const DirectoryInode& di) = 0;
  virtual int32_t chmod(const std::string& path, const DirectoryInode& di) = 0;
  virtual int32_t rmdir(const std::string& path, const DirectoryInode& di) = 0;
  virtual int32_t rename(const std::string& old_path, const std::string& new_path) = 0;
  virtual void getAttr(DirectoryInode& _return, const std::string& path, const DirectoryInode& di) = 0;
  virtual void readdir(std::string& _return, const std::string& path) = 0;
  virtual int32_t opendir(const std::string& path, const DirectoryInode& di) = 0;
};

class DMServiceIfFactory {
 public:
  typedef DMServiceIf Handler;

  virtual ~DMServiceIfFactory() {}

  virtual DMServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(DMServiceIf* /* handler */) = 0;
};

class DMServiceIfSingletonFactory : virtual public DMServiceIfFactory {
 public:
  DMServiceIfSingletonFactory(const boost::shared_ptr<DMServiceIf>& iface) : iface_(iface) {}
  virtual ~DMServiceIfSingletonFactory() {}

  virtual DMServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(DMServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<DMServiceIf> iface_;
};

class DMServiceNull : virtual public DMServiceIf {
 public:
  virtual ~DMServiceNull() {}
  int32_t mkdir(const std::string& /* path */, const DirectoryInode& /* di */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t access(const std::string& /* path */, const DirectoryInode& /* di */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t chown(const std::string& /* path */, const DirectoryInode& /* di */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t chmod(const std::string& /* path */, const DirectoryInode& /* di */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t rmdir(const std::string& /* path */, const DirectoryInode& /* di */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t rename(const std::string& /* old_path */, const std::string& /* new_path */) {
    int32_t _return = 0;
    return _return;
  }
  void getAttr(DirectoryInode& /* _return */, const std::string& /* path */, const DirectoryInode& /* di */) {
    return;
  }
  void readdir(std::string& /* _return */, const std::string& /* path */) {
    return;
  }
  int32_t opendir(const std::string& /* path */, const DirectoryInode& /* di */) {
    int32_t _return = 0;
    return _return;
  }
};

typedef struct _DMService_mkdir_args__isset {
  _DMService_mkdir_args__isset() : path(false), di(false) {}
  bool path;
  bool di;
} _DMService_mkdir_args__isset;

class DMService_mkdir_args {
 public:

  DMService_mkdir_args() : path() {
  }

  virtual ~DMService_mkdir_args() throw() {}

  std::string path;
  DirectoryInode di;

  _DMService_mkdir_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_di(const DirectoryInode& val) {
    di = val;
  }

  bool operator == (const DMService_mkdir_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(di == rhs.di))
      return false;
    return true;
  }
  bool operator != (const DMService_mkdir_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_mkdir_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_mkdir_pargs {
 public:


  virtual ~DMService_mkdir_pargs() throw() {}

  const std::string* path;
  const DirectoryInode* di;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_mkdir_result__isset {
  _DMService_mkdir_result__isset() : success(false), ppe(false), dee(false), nae(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nae;
  bool ipe;
} _DMService_mkdir_result__isset;

class DMService_mkdir_result {
 public:

  DMService_mkdir_result() : success(0) {
  }

  virtual ~DMService_mkdir_result() throw() {}

  int32_t success;
  ParentPathNotFoundException ppe;
  AlreayExistDirectoryException dee;
  NotADirectoryException nae;
  IllegalPathException ipe;

  _DMService_mkdir_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const AlreayExistDirectoryException& val) {
    dee = val;
  }

  void __set_nae(const NotADirectoryException& val) {
    nae = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_mkdir_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nae == rhs.nae))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_mkdir_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_mkdir_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_mkdir_presult__isset {
  _DMService_mkdir_presult__isset() : success(false), ppe(false), dee(false), nae(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nae;
  bool ipe;
} _DMService_mkdir_presult__isset;

class DMService_mkdir_presult {
 public:


  virtual ~DMService_mkdir_presult() throw() {}

  int32_t* success;
  ParentPathNotFoundException ppe;
  AlreayExistDirectoryException dee;
  NotADirectoryException nae;
  IllegalPathException ipe;

  _DMService_mkdir_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_access_args__isset {
  _DMService_access_args__isset() : path(false), di(false) {}
  bool path;
  bool di;
} _DMService_access_args__isset;

class DMService_access_args {
 public:

  DMService_access_args() : path() {
  }

  virtual ~DMService_access_args() throw() {}

  std::string path;
  DirectoryInode di;

  _DMService_access_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_di(const DirectoryInode& val) {
    di = val;
  }

  bool operator == (const DMService_access_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(di == rhs.di))
      return false;
    return true;
  }
  bool operator != (const DMService_access_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_access_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_access_pargs {
 public:


  virtual ~DMService_access_pargs() throw() {}

  const std::string* path;
  const DirectoryInode* di;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_access_result__isset {
  _DMService_access_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_access_result__isset;

class DMService_access_result {
 public:

  DMService_access_result() : success(0) {
  }

  virtual ~DMService_access_result() throw() {}

  int32_t success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_access_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_access_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_access_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_access_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_access_presult__isset {
  _DMService_access_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_access_presult__isset;

class DMService_access_presult {
 public:


  virtual ~DMService_access_presult() throw() {}

  int32_t* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_access_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_chown_args__isset {
  _DMService_chown_args__isset() : path(false), di(false) {}
  bool path;
  bool di;
} _DMService_chown_args__isset;

class DMService_chown_args {
 public:

  DMService_chown_args() : path() {
  }

  virtual ~DMService_chown_args() throw() {}

  std::string path;
  DirectoryInode di;

  _DMService_chown_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_di(const DirectoryInode& val) {
    di = val;
  }

  bool operator == (const DMService_chown_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(di == rhs.di))
      return false;
    return true;
  }
  bool operator != (const DMService_chown_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_chown_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_chown_pargs {
 public:


  virtual ~DMService_chown_pargs() throw() {}

  const std::string* path;
  const DirectoryInode* di;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_chown_result__isset {
  _DMService_chown_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_chown_result__isset;

class DMService_chown_result {
 public:

  DMService_chown_result() : success(0) {
  }

  virtual ~DMService_chown_result() throw() {}

  int32_t success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_chown_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_chown_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_chown_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_chown_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_chown_presult__isset {
  _DMService_chown_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_chown_presult__isset;

class DMService_chown_presult {
 public:


  virtual ~DMService_chown_presult() throw() {}

  int32_t* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_chown_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_chmod_args__isset {
  _DMService_chmod_args__isset() : path(false), di(false) {}
  bool path;
  bool di;
} _DMService_chmod_args__isset;

class DMService_chmod_args {
 public:

  DMService_chmod_args() : path() {
  }

  virtual ~DMService_chmod_args() throw() {}

  std::string path;
  DirectoryInode di;

  _DMService_chmod_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_di(const DirectoryInode& val) {
    di = val;
  }

  bool operator == (const DMService_chmod_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(di == rhs.di))
      return false;
    return true;
  }
  bool operator != (const DMService_chmod_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_chmod_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_chmod_pargs {
 public:


  virtual ~DMService_chmod_pargs() throw() {}

  const std::string* path;
  const DirectoryInode* di;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_chmod_result__isset {
  _DMService_chmod_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_chmod_result__isset;

class DMService_chmod_result {
 public:

  DMService_chmod_result() : success(0) {
  }

  virtual ~DMService_chmod_result() throw() {}

  int32_t success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_chmod_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_chmod_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_chmod_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_chmod_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_chmod_presult__isset {
  _DMService_chmod_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_chmod_presult__isset;

class DMService_chmod_presult {
 public:


  virtual ~DMService_chmod_presult() throw() {}

  int32_t* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_chmod_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_rmdir_args__isset {
  _DMService_rmdir_args__isset() : path(false), di(false) {}
  bool path;
  bool di;
} _DMService_rmdir_args__isset;

class DMService_rmdir_args {
 public:

  DMService_rmdir_args() : path() {
  }

  virtual ~DMService_rmdir_args() throw() {}

  std::string path;
  DirectoryInode di;

  _DMService_rmdir_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_di(const DirectoryInode& val) {
    di = val;
  }

  bool operator == (const DMService_rmdir_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(di == rhs.di))
      return false;
    return true;
  }
  bool operator != (const DMService_rmdir_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_rmdir_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_rmdir_pargs {
 public:


  virtual ~DMService_rmdir_pargs() throw() {}

  const std::string* path;
  const DirectoryInode* di;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_rmdir_result__isset {
  _DMService_rmdir_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_rmdir_result__isset;

class DMService_rmdir_result {
 public:

  DMService_rmdir_result() : success(0) {
  }

  virtual ~DMService_rmdir_result() throw() {}

  int32_t success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_rmdir_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_rmdir_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_rmdir_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_rmdir_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_rmdir_presult__isset {
  _DMService_rmdir_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_rmdir_presult__isset;

class DMService_rmdir_presult {
 public:


  virtual ~DMService_rmdir_presult() throw() {}

  int32_t* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_rmdir_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_rename_args__isset {
  _DMService_rename_args__isset() : old_path(false), new_path(false) {}
  bool old_path;
  bool new_path;
} _DMService_rename_args__isset;

class DMService_rename_args {
 public:

  DMService_rename_args() : old_path(), new_path() {
  }

  virtual ~DMService_rename_args() throw() {}

  std::string old_path;
  std::string new_path;

  _DMService_rename_args__isset __isset;

  void __set_old_path(const std::string& val) {
    old_path = val;
  }

  void __set_new_path(const std::string& val) {
    new_path = val;
  }

  bool operator == (const DMService_rename_args & rhs) const
  {
    if (!(old_path == rhs.old_path))
      return false;
    if (!(new_path == rhs.new_path))
      return false;
    return true;
  }
  bool operator != (const DMService_rename_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_rename_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_rename_pargs {
 public:


  virtual ~DMService_rename_pargs() throw() {}

  const std::string* old_path;
  const std::string* new_path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_rename_result__isset {
  _DMService_rename_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_rename_result__isset;

class DMService_rename_result {
 public:

  DMService_rename_result() : success(0) {
  }

  virtual ~DMService_rename_result() throw() {}

  int32_t success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_rename_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_rename_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_rename_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_rename_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_rename_presult__isset {
  _DMService_rename_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_rename_presult__isset;

class DMService_rename_presult {
 public:


  virtual ~DMService_rename_presult() throw() {}

  int32_t* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_rename_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_getAttr_args__isset {
  _DMService_getAttr_args__isset() : path(false), di(false) {}
  bool path;
  bool di;
} _DMService_getAttr_args__isset;

class DMService_getAttr_args {
 public:

  DMService_getAttr_args() : path() {
  }

  virtual ~DMService_getAttr_args() throw() {}

  std::string path;
  DirectoryInode di;

  _DMService_getAttr_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_di(const DirectoryInode& val) {
    di = val;
  }

  bool operator == (const DMService_getAttr_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(di == rhs.di))
      return false;
    return true;
  }
  bool operator != (const DMService_getAttr_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_getAttr_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_getAttr_pargs {
 public:


  virtual ~DMService_getAttr_pargs() throw() {}

  const std::string* path;
  const DirectoryInode* di;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_getAttr_result__isset {
  _DMService_getAttr_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_getAttr_result__isset;

class DMService_getAttr_result {
 public:

  DMService_getAttr_result() {
  }

  virtual ~DMService_getAttr_result() throw() {}

  DirectoryInode success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_getAttr_result__isset __isset;

  void __set_success(const DirectoryInode& val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_getAttr_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_getAttr_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_getAttr_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_getAttr_presult__isset {
  _DMService_getAttr_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_getAttr_presult__isset;

class DMService_getAttr_presult {
 public:


  virtual ~DMService_getAttr_presult() throw() {}

  DirectoryInode* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_getAttr_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_readdir_args__isset {
  _DMService_readdir_args__isset() : path(false) {}
  bool path;
} _DMService_readdir_args__isset;

class DMService_readdir_args {
 public:

  DMService_readdir_args() : path() {
  }

  virtual ~DMService_readdir_args() throw() {}

  std::string path;

  _DMService_readdir_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const DMService_readdir_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const DMService_readdir_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_readdir_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_readdir_pargs {
 public:


  virtual ~DMService_readdir_pargs() throw() {}

  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_readdir_result__isset {
  _DMService_readdir_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_readdir_result__isset;

class DMService_readdir_result {
 public:

  DMService_readdir_result() : success() {
  }

  virtual ~DMService_readdir_result() throw() {}

  std::string success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_readdir_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_readdir_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_readdir_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_readdir_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_readdir_presult__isset {
  _DMService_readdir_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_readdir_presult__isset;

class DMService_readdir_presult {
 public:


  virtual ~DMService_readdir_presult() throw() {}

  std::string* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_readdir_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DMService_opendir_args__isset {
  _DMService_opendir_args__isset() : path(false), di(false) {}
  bool path;
  bool di;
} _DMService_opendir_args__isset;

class DMService_opendir_args {
 public:

  DMService_opendir_args() : path() {
  }

  virtual ~DMService_opendir_args() throw() {}

  std::string path;
  DirectoryInode di;

  _DMService_opendir_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_di(const DirectoryInode& val) {
    di = val;
  }

  bool operator == (const DMService_opendir_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(di == rhs.di))
      return false;
    return true;
  }
  bool operator != (const DMService_opendir_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_opendir_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DMService_opendir_pargs {
 public:


  virtual ~DMService_opendir_pargs() throw() {}

  const std::string* path;
  const DirectoryInode* di;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_opendir_result__isset {
  _DMService_opendir_result__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_opendir_result__isset;

class DMService_opendir_result {
 public:

  DMService_opendir_result() : success(0) {
  }

  virtual ~DMService_opendir_result() throw() {}

  int32_t success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_opendir_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ppe(const ParentPathNotFoundException& val) {
    ppe = val;
  }

  void __set_dee(const NotFoundDirectoryException& val) {
    dee = val;
  }

  void __set_nde(const NotADirectoryException& val) {
    nde = val;
  }

  void __set_ipe(const IllegalPathException& val) {
    ipe = val;
  }

  bool operator == (const DMService_opendir_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ppe == rhs.ppe))
      return false;
    if (!(dee == rhs.dee))
      return false;
    if (!(nde == rhs.nde))
      return false;
    if (!(ipe == rhs.ipe))
      return false;
    return true;
  }
  bool operator != (const DMService_opendir_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DMService_opendir_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DMService_opendir_presult__isset {
  _DMService_opendir_presult__isset() : success(false), ppe(false), dee(false), nde(false), ipe(false) {}
  bool success;
  bool ppe;
  bool dee;
  bool nde;
  bool ipe;
} _DMService_opendir_presult__isset;

class DMService_opendir_presult {
 public:


  virtual ~DMService_opendir_presult() throw() {}

  int32_t* success;
  ParentPathNotFoundException ppe;
  NotFoundDirectoryException dee;
  NotADirectoryException nde;
  IllegalPathException ipe;

  _DMService_opendir_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class DMServiceClient : virtual public DMServiceIf {
 public:
  DMServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  DMServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  int32_t mkdir(const std::string& path, const DirectoryInode& di);
  void send_mkdir(const std::string& path, const DirectoryInode& di);
  int32_t recv_mkdir();
  int32_t access(const std::string& path, const DirectoryInode& di);
  void send_access(const std::string& path, const DirectoryInode& di);
  int32_t recv_access();
  int32_t chown(const std::string& path, const DirectoryInode& di);
  void send_chown(const std::string& path, const DirectoryInode& di);
  int32_t recv_chown();
  int32_t chmod(const std::string& path, const DirectoryInode& di);
  void send_chmod(const std::string& path, const DirectoryInode& di);
  int32_t recv_chmod();
  int32_t rmdir(const std::string& path, const DirectoryInode& di);
  void send_rmdir(const std::string& path, const DirectoryInode& di);
  int32_t recv_rmdir();
  int32_t rename(const std::string& old_path, const std::string& new_path);
  void send_rename(const std::string& old_path, const std::string& new_path);
  int32_t recv_rename();
  void getAttr(DirectoryInode& _return, const std::string& path, const DirectoryInode& di);
  void send_getAttr(const std::string& path, const DirectoryInode& di);
  void recv_getAttr(DirectoryInode& _return);
  void readdir(std::string& _return, const std::string& path);
  void send_readdir(const std::string& path);
  void recv_readdir(std::string& _return);
  int32_t opendir(const std::string& path, const DirectoryInode& di);
  void send_opendir(const std::string& path, const DirectoryInode& di);
  int32_t recv_opendir();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class DMServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<DMServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (DMServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_mkdir(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_access(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_chown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_chmod(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rmdir(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rename(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getAttr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_readdir(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_opendir(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  DMServiceProcessor(boost::shared_ptr<DMServiceIf> iface) :
    iface_(iface) {
    processMap_["mkdir"] = &DMServiceProcessor::process_mkdir;
    processMap_["access"] = &DMServiceProcessor::process_access;
    processMap_["chown"] = &DMServiceProcessor::process_chown;
    processMap_["chmod"] = &DMServiceProcessor::process_chmod;
    processMap_["rmdir"] = &DMServiceProcessor::process_rmdir;
    processMap_["rename"] = &DMServiceProcessor::process_rename;
    processMap_["getAttr"] = &DMServiceProcessor::process_getAttr;
    processMap_["readdir"] = &DMServiceProcessor::process_readdir;
    processMap_["opendir"] = &DMServiceProcessor::process_opendir;
  }

  virtual ~DMServiceProcessor() {}
};

class DMServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  DMServiceProcessorFactory(const ::boost::shared_ptr< DMServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< DMServiceIfFactory > handlerFactory_;
};

class DMServiceMultiface : virtual public DMServiceIf {
 public:
  DMServiceMultiface(std::vector<boost::shared_ptr<DMServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~DMServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<DMServiceIf> > ifaces_;
  DMServiceMultiface() {}
  void add(boost::shared_ptr<DMServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  int32_t mkdir(const std::string& path, const DirectoryInode& di) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mkdir(path, di);
    }
    return ifaces_[i]->mkdir(path, di);
  }

  int32_t access(const std::string& path, const DirectoryInode& di) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->access(path, di);
    }
    return ifaces_[i]->access(path, di);
  }

  int32_t chown(const std::string& path, const DirectoryInode& di) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->chown(path, di);
    }
    return ifaces_[i]->chown(path, di);
  }

  int32_t chmod(const std::string& path, const DirectoryInode& di) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->chmod(path, di);
    }
    return ifaces_[i]->chmod(path, di);
  }

  int32_t rmdir(const std::string& path, const DirectoryInode& di) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rmdir(path, di);
    }
    return ifaces_[i]->rmdir(path, di);
  }

  int32_t rename(const std::string& old_path, const std::string& new_path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rename(old_path, new_path);
    }
    return ifaces_[i]->rename(old_path, new_path);
  }

  void getAttr(DirectoryInode& _return, const std::string& path, const DirectoryInode& di) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getAttr(_return, path, di);
    }
    ifaces_[i]->getAttr(_return, path, di);
    return;
  }

  void readdir(std::string& _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->readdir(_return, path);
    }
    ifaces_[i]->readdir(_return, path);
    return;
  }

  int32_t opendir(const std::string& path, const DirectoryInode& di) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->opendir(path, di);
    }
    return ifaces_[i]->opendir(path, di);
  }

};

} // namespace

#endif
